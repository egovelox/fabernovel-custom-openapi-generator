import { writeFileSync } from "fs";
import path from "path";
import { printRuntime } from "io-ts-codegen";
import { checkOrCreateFolder, copyFile } from "../../utils/files";
import {
  Dependency,
  RequiredReferenceItem,
  RequiredReferenceMap,
} from "../../utils/generateSchemas";
import { TypeRessources } from "../../utils/parseSupportTypes";

export async function writeTypeFiles(
  referenceMap: RequiredReferenceMap,
  supportTypes: TypeRessources,
  params: { outputFolder: string }
) {
  checkOrCreateFolder(params.outputFolder, true);
  await asyncForEach(Object.values(referenceMap), async (referenceItem) => {
    const filename = `${referenceItem.name}.ts`;
    const completePath = path.join(params.outputFolder, filename);

    const file = await makeFile(
      params.outputFolder,
      referenceItem,
      supportTypes
    );
    console.info(
      `Writing type ${referenceItem.name}.ts > ${path.relative(
        process.cwd(),
        completePath
      )}`
    );
    writeFileSync(completePath, file);
  });
}

async function resolveDependency(
  destinationFolder: string,
  dependency: Dependency,
  supportTypes: TypeRessources
) {
  if (dependency.utilitary) {
    const typeRessource = supportTypes[dependency.name];

    if (typeRessource !== undefined) {
      const supportFolderPath = path.join(destinationFolder, "_support");
      const completeFilePath = path.join(
        supportFolderPath,
        `${dependency.name}`
      );
      checkOrCreateFolder(supportFolderPath);

      try {
        await copyFile(typeRessource.system_path, `${completeFilePath}.ts`);

        return `import { ${
          typeRessource.export_name
        } } from "${makePathRelative(
          "_support",
          path.relative(destinationFolder, completeFilePath)
        )}"`;
      } catch (e) {
        console.error(
          `Could not copy file ${dependency.name} from ${typeRessource.system_path} to ${supportFolderPath}`
        );
        return "";
      }
    } else {
      return "";
    }
  } else {
    return `import { ${dependency.name} } from "./${dependency.name}"`;
  }
}

async function resolveDependencies(
  destinationFolder: string,
  dependencies: Dependency[],
  supportTypes: TypeRessources
) {
  return await Promise.all(
    dependencies.map((dependency) =>
      resolveDependency(destinationFolder, dependency, supportTypes)
    )
  );
}

async function makeFile(
  destinationFolder: string,
  referenceItem: RequiredReferenceItem,
  supportTypes: TypeRessources
): Promise<string> {
  const dependencies = await resolveDependencies(
    destinationFolder,
    referenceItem.dependencies,
    supportTypes
  );
  const file = [
    `//
// THIS FILE HAS BEEN AUTOGENERATED. DO NOT MODIFY.
//
`,
    `import * as t from "io-ts"`,
  ]
    .concat(
      dependencies.filter((importStatement) => importStatement.length > 0)
    )
    .concat([
      "",
      `export const ${referenceItem.name}Schema = JSON.parse(\`${JSON.stringify(
        referenceItem.schema,
        null,
        2
      )
        .replace(/\`/g, "\\`")
        .replace(/\\r/g, "\\\\r")
        .replace(/\\n/g, "\\\\n")}\`);`,
      "",
      `export const ${referenceItem.name} = ${printRuntime(
        referenceItem.type
      )};`,
      "",
      `export type ${referenceItem.name} = t.TypeOf<typeof ${referenceItem.name}>`,
    ]);

  return file.join("\n");
}

async function asyncForEach<T>(
  array: Array<T>,
  callback: (item: T, index: number, array: Array<T>) => Promise<void>
) {
  for (let index = 0; index < array.length; index++) {
    await callback(array[index], index, array);
  }
}

function makePathRelative(baseFolderName: string, path: string) {
  if (path.startsWith(baseFolderName)) {
    return `./${path}`;
  } else {
    return path;
  }
}
