import path from "path";
import { writeFileSync } from "fs";

import { RouteItem, GroupedRoutes } from "./../groupRoutes";
import { Method, methods } from "../../../types/methods";

import { makeHandler } from "./makeHandler";

import { RequiredReferenceMap } from "../../../utils/generateSchemas";
import { checkOrCreateFolder } from "../../../utils/files";
import { getHandlerName } from "../../../utils/openapi";
import { capitalize } from "../../../utils/strings";
import { addTypeImportFn } from "./types";
import { removeUndefinedValues } from "../../../utils/array";

function makeFile(
  tag: { name: string; contractName: string },
  routeItems: RouteItem[],
  params: {
    types: RequiredReferenceMap;
    typesFolder: string;
    outputFolder: string;
  }
) {
  const dependencyNamedImports: string[] = [];

  // Find type in import reference and add it to the file
  const addTypeImport: addTypeImportFn = (ref) => {
    const type = params.types[ref];
    if (
      type !== undefined &&
      !dependencyNamedImports.some((dep) => dep === type.name)
    ) {
      dependencyNamedImports.push(type.name);
    }
    return type?.name;
  };

  const operationIds: string[] = [];

  const handlers = routeItems.map((routeItem) => {
    return Object.keys(routeItem.item)
      .filter(
        // Get only method properties
        (key: string): key is Method => methods.indexOf(key as Method) >= 0
      )
      .map((method) => {
        const operationObject = routeItem.item[method]!;
        const handlerName = getHandlerName(operationObject);
        operationIds.push(handlerName);
        return makeHandler(
          handlerName,
          operationObject,
          addTypeImport,
          params.types
        );
      })
      .filter((routeDef) => routeDef.length > 0)
      .join("\n");
  });

  let file = [
    `// ${tag.name} handlers contract`,
    `// AUTOGENERATED FILE, MODIFY WITH CARE`,
    `import { RouteHandlerMethod, RouteGenericInterface } from "fastify/types/route";`,
    `import {
  RawRequestDefaultExpression,
  RawReplyDefaultExpression,
  RawServerBase,
} from "fastify/types/utils";`,
    //io-ts import is needed for types like t.Int
    `import * as t from "io-ts";`,
    `import * as http from "http";`,
  ]
    .concat(
      removeUndefinedValues(
        dependencyNamedImports.map((name) =>
          name.length > 0
            ? `import { ${name} } from "${path.relative(
                params.outputFolder,
                path.join(params.typesFolder, `${name}`)
              )}"`
            : undefined
        )
      )
    )
    .concat([""])
    .concat(handlers)
    .concat([
      "",
      `interface ${tag.contractName}<S extends RawServerBase = http.Server> {
  ${operationIds
    .map((operationId) => `${operationId}: ${capitalize(operationId)}<S>`)
    .join(";\n  ")}
}`,
      "",
      `export default ${tag.contractName}`,
    ]);

  return file.join("\n");
}

export async function writeContracts(
  groupedRoutes: GroupedRoutes,
  types: RequiredReferenceMap,
  params: { outputFolder: string; typesFolder: string }
) {
  checkOrCreateFolder(params.outputFolder, true);
  Object.keys(groupedRoutes).forEach((tag) => {
    const contractName = makeContractName(tag);
    const filepath = path.resolve(
      process.cwd(),
      path.join(params.outputFolder, `${contractName}.ts`)
    );
    console.info(
      `Making file ${contractName}.ts > ${path.relative(
        process.cwd(),
        filepath
      )}`
    );
    const file = makeFile({ name: tag, contractName }, groupedRoutes[tag], {
      types,
      ...params,
    });
    writeFileSync(filepath, file);
  });
}

export function makeContractName(tag: string) {
  return `${capitalize(tag)}Contract`;
}
