import { OpenAPIV3 } from "openapi-types";
import { writeFileSync } from "fs";
import path from "path";

import { ConfigCodeGenOperation } from "../../core/config";
import { GroupedRoutes, RouteItem } from "./groupRoutes";
import { makeContractName } from "./contracts/contractsSerializer";
import makeJsonSchemaParameter from "./fastifySchemas";
import { methods, Method } from "../../types/methods";

import { RequiredReferenceMap } from "../../utils/generateSchemas";
import {
  getHandlerName,
  getSchemaRef,
  getJsonSchema,
} from "../../utils/openapi";
import { removeUndefinedValues } from "../../utils/array";

export function writeFastifyRouter(
  groupedRoutes: GroupedRoutes,
  params: {
    types: RequiredReferenceMap;
    typesFolder: string;
    config: ConfigCodeGenOperation;
  }
) {
  const file = makeFile(groupedRoutes, params.types, params.config);
  console.info(
    `Writing file registerFastify.ts > ${path.relative(
      process.cwd(),
      params.config.output
    )}`
  );
  writeFileSync(params.config.output, file);
}

export function makeFile(
  groupedRoutes: GroupedRoutes,
  types: RequiredReferenceMap,
  config: ConfigCodeGenOperation
) {
  return removeUndefinedValues([
    `// AUTOGENERATED FILE, MODIFY WITH CARE`,
    ...makeFastifyImports(config),
    ...makeIotsImports(config),
    ...makeTypeImports(types, config),
    makeContractImports(groupedRoutes),

    config.type === "fastify" && config.iotsRouter
      ? wrapperFunction
      : undefined,
    config.type === "fastify" && config.iotsRouter
      ? writeErrorsFunction
      : undefined,

    makeAllContractsInterface(groupedRoutes),
    makeRegisterFn(groupedRoutes, types, config),
  ]).join("\n");
}

function makeFastifyImports(config: ConfigCodeGenOperation): string[] {
  if (config.type === "fastify" && config.iotsRouter) {
    return [
      `import * as http from "http";`,
      `import { RouteGenericInterface, RouteHandlerMethod } from "fastify/types/route";`,
      `import {
  RawRequestDefaultExpression,
  RawReplyDefaultExpression,
  RawServerBase,
} from "fastify/types/utils";`,
      `import { FastifyInstance } from "fastify/types/instance";`,
      ``,
    ];
  } else {
    return [
      `import * as http from "http";`,
      `import { RawServerBase } from "fastify/types/utils";`,
      `import { FastifyInstance } from "fastify/types/instance";`,
      "",
    ];
  }
}

function makeIotsImports(config: ConfigCodeGenOperation): string[] {
  if (config.type === "fastify" && config.iotsRouter) {
    return [
      `import * as t from "io-ts";`,
      `import * as E from "fp-ts/lib/Either";`,
      `import { pipe } from "fp-ts/lib/pipeable"`,
      ``,
    ];
  } else {
    return [];
  }
}

function makeTypeImports(
  types: RequiredReferenceMap,
  config: ConfigCodeGenOperation
): string[] {
  const names = Object.values(types).map((v) => v.name);
  if (config.type === "fastify" && config.iotsRouter && !config.noSchemas) {
    return names.map(
      (name) => `import {${name}, ${name}Schema} from "../types/${name}"`
    );
  } else if (config.type === "fastify" && config.iotsRouter) {
    return names.map((name) => `import {${name}} from "../types/${name}"`);
  } else if (config.type === "fastify" && !config.noSchemas) {
    return names.map(
      (name) => `import {${name}Schema} from "../types/${name}"`
    );
  } else {
    return [];
  }
}

function makeContractImports(groupedRoutes: GroupedRoutes): string {
  return Object.keys(groupedRoutes)
    .map(
      (tag) =>
        `import ${makeContractName(tag)} from './${makeContractName(tag)}'`
    )
    .join("\n");
}

const HandlerInterface = "Handlers";

function makeAllContractsInterface(groupedRoutes: GroupedRoutes): string {
  const contracts = Object.keys(groupedRoutes)
    .map((tag) => `  ${tag}: ${makeContractName(tag)}<S>`)
    .join("\n");
  return `
export interface ${HandlerInterface}<S extends RawServerBase = http.Server> {
${contracts}
}`;
}

function makeRegisterFn(
  groupedRoutes: GroupedRoutes,
  types: RequiredReferenceMap,
  config: ConfigCodeGenOperation
): string {
  const registerStatements = Object.entries(groupedRoutes)
    .flatMap(([tag, endpoints]) =>
      endpoints.map((e): [string, RouteItem] => [tag, e])
    )
    .flatMap(([tag, endpoint]) =>
      methods.map((m) => {
        const item = endpoint.item[m];
        if (item !== undefined) {
          return makeRegisterEndpoint(
            m,
            endpoint.path,
            tag,
            item,
            types,
            config
          );
        } else {
          return undefined;
        }
      })
    )
    .filter((a): a is string => a != undefined);

  return `
export function registerFastify<S extends RawServerBase = http.Server, I extends FastifyInstance<S> = FastifyInstance<S>>(server: I, handlers: ${HandlerInterface}<S>) {
  ${registerStatements.join("\n  ")}
}`;
}

function makeRegisterEndpoint(
  verb: Method,
  path: string,
  tag: string,
  operation: OpenAPIV3.OperationObject,
  types: RequiredReferenceMap,
  config: ConfigCodeGenOperation
) {
  const url = `'${preparePath(path)}'`;
  const jsonSchemaParameter = makeJsonSchemaParameter(operation, types, config);
  const handler = makeRegisterHandler(operation, types, tag, config);

  return `server.${verb}(${url},${jsonSchemaParameter} ${handler});`;
}

function preparePath(path: string): string {
  // eg: "/collection/{id}" => "/collection/:id"
  return path.replace(/\{([^}]+)\}/g, ":$1");
}

function makeRegisterHandler(
  operation: OpenAPIV3.OperationObject,
  types: RequiredReferenceMap,
  tag: string,
  config: ConfigCodeGenOperation
): string {
  const handler = `handlers.${tag}.${getHandlerName(operation)}`;
  const requestBodyType = getSchemaRef(
    getJsonSchema(operation.requestBody),
    types
  );
  if (
    config.type === "fastify" &&
    config.iotsRouter === true &&
    requestBodyType !== undefined
  ) {
    return `wrap(${requestBodyType}, ${handler})`;
  } else {
    return handler;
  }
}

const wrapperFunction = `
function wrap<
  S extends RawServerBase = http.Server,
  RouteGeneric extends RouteGenericInterface = RouteGenericInterface
>(
  bodyCodec: t.Decoder<any, RouteGeneric["Body"]>,
  handler: RouteHandlerMethod<
    S,
    RawRequestDefaultExpression<S>,
    RawReplyDefaultExpression<S>,
    RouteGeneric
  >
): RouteHandlerMethod<
  S,
  RawRequestDefaultExpression<S>,
  RawReplyDefaultExpression<S>,
  RouteGeneric
> {
  return function (this, request, reply) {
    return pipe(
      bodyCodec.decode(request.body),
      E.mapLeft((errs) => ({
        message: "invalid parameters in body",
        errors: formatValidationErrors(errs),
      })),
      E.fold(
        (err) => {
          reply.status(400).send(err);
        },
        (parsed) => handler.call(this, Object.create(request, { body: { value: parsed } }), reply)
      )
    );
  };
}`;

const writeErrorsFunction = `
function formatValidationErrors(errors: t.Errors): string[] {
  return errors.map(error => {
    const path = error.context
      .filter(({ type }) => {
        const tag = (type as any)?._tag
        // hack to avoid numbers in the middle of the path
        return tag !== 'IntersectionType' && tag !== 'InterfaceType'
      })
      .map(({ key }) => key)
      .join('.')
    const expected = error.context[error.context.length - 1].type.name
    return \`\${error.message || 'A validation error occured'} at \${path} (value: \${
      error.value
    }; expected: \${expected})\`
  })
}
`;
